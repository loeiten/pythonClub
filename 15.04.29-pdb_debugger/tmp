https://docs.python.org/3.4/library/pdb.html

# From command line
python3 -m pdb myscript.py

# Running script
import pdb; pdb.set_trace()

# In interpreter


% Source: learncpp and the below
Frame = stack frame => function calls are put on top of each other in the memory
Traceback = Prints the stack trace (analogy of plates)
% Example of stack
http://www.cs.swarthmore.edu/~richardw/cs21-s12/stack-example.pdf


Post-mortem
>>> import pdb
>>> import mymodule
>>> mymodule.test()
Traceback (most recent call last):
  File "<stdin>", line 1, in ?
  File "./mymodule.py", line 4, in test
    test2()
  File "./mymodule.py", line 3, in test2
    print(spam)
NameError: spam
>>> pdb.pm()


Post mortem running as script
%
http://stackoverflow.com/questions/242485/starting-python-debugger-automatically-on-error
import pdb, traceback, sys

def bombs():
    a = []
    print a[0]

if __name__ == '__main__':
    try:
        bombs()
    except:
        type, value, tb = sys.exc_info()
        traceback.print_exc()
        pdb.post_mortem(tb)




How to start debugger

# Execute the statement
pdb.run(statement, globals=None, locals=None)
# As above, and returns the value of the expression
pdb.runeval(expression, globals=None, locals=None)
# Call a function
pdb.runcall(function, *args, **kwds)
# Hardcode a breakpoint
pdb.set_trace()
# Enter debugger at post mortem given the traceback, if none is given it takes the current exception
pdb.post_mortem(traceback=None)
# Enters pdb of last found traceback
pdb.pm()
# Can also do all of this manually (not covered here) by
pdb.Pdb(completekey='tab', stdin=None, stdout=None, skip=None, nosigint=False)




# Help and documentation (demo)
h(elp) [command]
# Print the stac trace (recent frame in bottom)
w(here)
# Move frames (check)
d(own) [count]
u(p) [count]
# W/o arguments: List the breakpoints
# Make a breakpoint (where the debugger will stop)
# Honor the breakpoint if condition evaluates true
b(reak) [([filename:]lineno | function) [, condition]]
# Temporary breakpoint (removed when hit)
tbreak [([filename:]lineno | function) [, condition]]
# Clear breakpoints
cl(ear) [filename:lineno | bpnumber [bpnumber ...]]
# Disable breakpoints (can be re-enabled)
disable [bpnumber [bpnumber ...]]
# Enable bp number
enable [bpnumber [bpnumber ...]]
# Ignore bp count times (if cout>0)
ignore bpnumber [count]
# Set new condition for the bp (demo)
condition bpnumber [condition]
# Specify commands for bpnumber (or the last)
# end ends the command
# silent disables info about bp reached (demo)
commands [bpnumber]

# Print type of expression
whatis expression
# Try to get the source for the given object
source expression

# Stop and display the value of the expression if changed (demo)
# Somewhat similar to watchpoints in gdb
display [expression]
# Stop displaying in current frame
undisplay [expression]
# Start interactive interpreter and load the globals and locals in the current scope
# Stop with CTRL-D
interact
# Create an alias (demo) foo print('hello'))
alias [name [command]]
# Delete alias
unalias name
# Execute the (one-line) statement in the context of the current stack frame
# Exclamation point can be omitted unless the first word of the statement resembles a debugger command
! statement
# Execute from following
run [args ...]
# Restart
restart [args ...]
# Quit the debugger
q(uit)






# Often used (demo) all
# Step into first possible occasion (can step into functions)
s(tep)
# Go to next line of expression
n(ext)
# Execute until lineno OR end of frame OR to a greater line than the current
# Convenient in for loops
unt(il) [lineno]
# Continue until function returns
r(eturn)
# Continue, only stop if bp is hit
c(ont(inue))
# Set next line to be executed (at the bottom most frame)
# Jump back and execute code again or skip part of code
# (Not always allowed)
j(ump) lineno
# List the source code around current line
l(ist) [first[, last]]
# List source for current function or frame
ll | longlist
# Print arguments of current function
a(rgs)
# Evaluate the expression, and print its value
# Similar to print(), but print() is a python function
p expression
# The same as above, but with prettyprinted function
pp expression
# Empty line: Previous command is repeated






# ~/.pdbrc
The file ~/.pdbrc is read first, allowing you to set global personal preferences for all of your debugging sessions. Then ./.pdbrc is read from the current working directory, so you can set local preferences for a particular project.



$ cat ~/.pdbrc
# Show python help
alias ph !help(%1)
# Overridden alias
alias redefined p 'home definition'

$ cat .pdbrc
# Breakpoints
break 10
# Overridden alias
alias redefined p 'local definition'

$ python -m pdb pdb_function_arguments.py
Breakpoint 1 at .../pdb_function_arguments.py:10
> .../pdb_function_arguments.py(7)<module>()
-> import pdb
(Pdb) alias
ph = !help(%1)
redefined = p 'local definition'

(Pdb) break
Num Type         Disp Enb   Where
1   breakpoint   keep yes   at .../pdb_function_arguments.py:10

(Pdb)







Demo
Let debugger execute before use print
Rename a var normally with (pdb) var ='BBB'
(pdb)b="bbb" vs (pdb)!b="bbb"
http://pymotw.com/2/pdb/#examining-variables-on-the-stack
Until in the below
http://pymotw.com/2/pdb/#stepping-through-your-program


Links
# Documentation
https://docs.python.org/3.4/library/pdb.html
# Basic debugging
https://pythonconquerstheuniverse.wordpress.com/2009/09/10/debugging-in-python/
# More indepth about debugging
http://pymotw.com/2/pdb/
